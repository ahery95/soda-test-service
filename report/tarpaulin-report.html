<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>var data = {"files":[{"path":["/","mnt","d","devhome","soda-test-service","src","cli","mod.rs"],"content":"use clap::{App, Arg, ArgMatches};\r\n\r\nfn validate_format(v: String) -\u003e Result\u003c(), String\u003e {\r\n    if v.contains(':') {\r\n        return Ok(());\r\n    }\r\n    Err(String::from(\"Format must be IP:PORT\"))\r\n}\r\n\r\npub fn init\u003c'a\u003e() -\u003e ArgMatches\u003c'a\u003e {\r\n    App::new(\"HTTP Proxy\")\r\n        .arg(\r\n            Arg::with_name(\"listen\")\r\n                .long(\"listen\")\r\n                .help(\"format : IP:PORT\")\r\n                .takes_value(true)\r\n                .validator(validate_format)\r\n                .required(true),\r\n        )\r\n        .arg(\r\n            Arg::with_name(\"forward\")\r\n                .long(\"forward\")\r\n                .help(\"format : IP:PORT\")\r\n                .takes_value(true)\r\n                .validator(validate_format)\r\n                .required(true),\r\n        )\r\n        .arg(\r\n            Arg::with_name(\"verbose\")\r\n                .short(\"-v\")\r\n                .long(\"verbose\")\r\n                .multiple(true)\r\n                .help(\"Make the server more talkative\")\r\n                .takes_value(false)\r\n                .required(false),\r\n        )\r\n        .arg(\r\n            Arg::with_name(\"timeout\")\r\n                .long(\"timeout\")\r\n                .help(\"format : DURATION_IN_SECS\")\r\n                .takes_value(true)\r\n                .required(true),\r\n        )\r\n        .get_matches()\r\n}\r\n","traces":[{"line":3,"address":4973808,"length":1,"stats":{"Line":0},"fn_name":"validate_format"},{"line":4,"address":4973820,"length":1,"stats":{"Line":0},"fn_name":null},{"line":5,"address":4973943,"length":1,"stats":{"Line":0},"fn_name":null},{"line":7,"address":4973914,"length":1,"stats":{"Line":0},"fn_name":null},{"line":10,"address":4974032,"length":1,"stats":{"Line":0},"fn_name":"init"},{"line":11,"address":4974055,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","mnt","d","devhome","soda-test-service","src","domain","capabilities.rs"],"content":"use std::fmt;\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Capabilities {\n    pub desired_capabilities: DesiredCapabilities,\n}\n\n#[derive(Debug, Deserialize, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct DesiredCapabilities {\n    pub browser_name: Option\u003cString\u003e,\n    pub platform: Option\u003cString\u003e,\n    #[serde(rename(deserialize = \"soda:user\"))]\n    pub soda_user: Option\u003cString\u003e,\n}\n\nimpl DesiredCapabilities {\n    fn new() -\u003e DesiredCapabilities {\n        DesiredCapabilities {\n            browser_name: None,\n            platform: None,\n            soda_user: None,\n        }\n    }\n}\n\nimpl fmt::Display for DesiredCapabilities {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        // Use `self.number` to refer to each positional data point.\n        write!(\n            f,\n            \"(browser: {}, platform: {}, user: {})\",\n            self.browser_name.clone().unwrap_or_else(|| \"\".to_string()),\n            self.platform.clone().unwrap_or_else(|| \"\".to_string()),\n            self.soda_user.clone().unwrap_or_else(|| \"\".to_string())\n        )\n    }\n}\n\nimpl Capabilities {\n    pub fn new() -\u003e Capabilities {\n        Capabilities {\n            desired_capabilities: DesiredCapabilities::new(),\n        }\n    }\n}\n","traces":[{"line":18,"address":4902864,"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":28,"address":4902992,"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":30,"address":4903228,"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":4903009,"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":4710080,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":34,"address":4710128,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":35,"address":4710176,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":41,"address":4903744,"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":43,"address":4903751,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","mnt","d","devhome","soda-test-service","src","domain","command.rs"],"content":"#[derive(Debug, Default, Deserialize)]\r\npub struct Command {\r\n    pub url: Option\u003cString\u003e,\r\n}\r\n\r\nimpl Command {\r\n    pub fn new() -\u003e Command {\r\n        Command {\r\n            url: Some(\"\".to_string()),\r\n        }\r\n    }\r\n\r\n    pub fn url(self) -\u003e String {\r\n        self.url.unwrap_or_else(|| \"\".to_string())\r\n    }\r\n}\r\n","traces":[{"line":7,"address":4527792,"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":9,"address":4527803,"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":4527904,"length":1,"stats":{"Line":1},"fn_name":"url"},{"line":14,"address":4337376,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"}],"covered":2,"coverable":4},{"path":["/","mnt","d","devhome","soda-test-service","src","domain","session.rs"],"content":"use std::fmt;\n\n#[derive(Debug, PartialEq)]\npub enum SessionStatus {\n    Creating,\n    UrlCommand,\n    Deleting,\n}\n\nimpl fmt::Display for SessionStatus {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match *self {\n            SessionStatus::Creating =\u003e write!(f, \"SESSION_CREATING\"),\n            SessionStatus::UrlCommand =\u003e write!(f, \"SESSION_URL_COMMAND\"),\n            SessionStatus::Deleting =\u003e write!(f, \"SESSION_DELETING\"),\n        }\n    }\n}\n","traces":[{"line":11,"address":4608288,"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":12,"address":4608400,"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":4608305,"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":4608486,"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":4608356,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":3,"coverable":5},{"path":["/","mnt","d","devhome","soda-test-service","src","inspector.rs"],"content":"use crate::domain;\r\nuse crate::reverse_proxy;\r\nuse bytes::Bytes;\r\nuse hyper::Method;\r\nuse std::fmt;\r\n\r\n#[derive(Debug, PartialEq)]\r\nstruct CreateEvent {\r\n    event: domain::session::SessionStatus,\r\n    desired_capabilities: domain::DesiredCapabilities,\r\n}\r\n#[derive(Debug, PartialEq)]\r\nstruct CommandEvent {\r\n    event: domain::session::SessionStatus,\r\n    session_id: String,\r\n    url: String,\r\n}\r\n\r\nimpl fmt::Display for CommandEvent {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        write!(f, \"({},{},{})\", self.event, self.session_id, self.url)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for CreateEvent {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        write!(f, \"({},{})\", self.event, self.desired_capabilities)\r\n    }\r\n}\r\n\r\npub async fn inspect\u003c'm, 'b\u003e(request: reverse_proxy::RequestToInspect\u003c'm, 'b\u003e) {\r\n    let method = request.method.to_owned();\r\n    let path = request.path;\r\n\r\n    info!(\"Inspecting the request {} {}\", method, path);\r\n\r\n    let body = request.body;\r\n\r\n    if method == Method::DELETE {\r\n        info!(\"{}\", capture_delete_event(path).await);\r\n    } else if method == Method::POST \u0026\u0026 is_a_new_session(\u0026path) {\r\n        println!(\"voici le path pour la new session : {} \", path);\r\n        info!(\"{}\", capture_create_event(body).await);\r\n    } else if method == \"POST\" \u0026\u0026 !is_a_new_session(\u0026path) {\r\n        if let Some(url_event) = capture_url_event(path, body) {\r\n            info!(\"{}\", url_event);\r\n        }\r\n    }\r\n}\r\n\r\nasync fn capture_delete_event(path: String) -\u003e String {\r\n    let session_id = session_id_of_path(path).unwrap_or_else(|| \"\".to_string());\r\n\r\n    format!(\r\n        \"[{}] [{}]\",\r\n        domain::session::SessionStatus::Deleting,\r\n        session_id\r\n    )\r\n    // user IP/ID | session status | session ID\r\n}\r\n\r\n/// Capture new sessions events\r\nasync fn capture_create_event(body: \u0026Bytes) -\u003e CreateEvent {\r\n    let capabilities: domain::Capabilities = serde_json::from_slice(body)\r\n        .map_err(|_| {\r\n            error!(\r\n                \"Fail to deserialize the capabilities for the given payload : {:?}\",\r\n                body\r\n            );\r\n        })\r\n        .unwrap_or_else(|_| domain::Capabilities::new());\r\n\r\n    let desired_capabilities = capabilities.desired_capabilities;\r\n\r\n    CreateEvent {\r\n        event: domain::session::SessionStatus::Creating,\r\n        desired_capabilities,\r\n    }\r\n    //status session pass to creating  user IP/ID | session status | Platform | Browser\r\n}\r\n\r\n/// Capture asked url events\r\nfn capture_url_event(path: String, body: \u0026Bytes) -\u003e Option\u003cCommandEvent\u003e {\r\n    if path.contains(\"/url\") {\r\n        let command: domain::Command = serde_json::from_slice(body)\r\n            .map_err(|_| {\r\n                error!(\r\n                    \"Fail to deserialize the capabilities for the given payload : {:?}\",\r\n                    body\r\n                );\r\n            })\r\n            .unwrap_or_else(|_| domain::Command::new());\r\n\r\n        let session = session_id_of_path(path).unwrap_or_else(|| \"\".to_string());\r\n\r\n        // user IP/ID | session_status | session ID | url_command | url\r\n        return Some(CommandEvent {\r\n            event: domain::session::SessionStatus::UrlCommand,\r\n            session_id: session,\r\n            url: command.url(),\r\n        });\r\n    }\r\n\r\n    None\r\n}\r\n/// Split the path to determine if it's a new session\r\n/// (the path doesn't contain the session's id) or if it's\r\n/// an existing session (the path contains the session's id).\r\n/// If the head and the tail of the path are empty,\r\n/// it's a new session event that we want to capture.\r\nfn is_a_new_session(path: \u0026str) -\u003e bool {\r\n    let splitted_path: Vec\u003c\u0026str\u003e = path\r\n        .split(\"/wd/hub/session\")\r\n        .filter(|item| !item.is_empty())\r\n        .collect();\r\n\r\n    splitted_path.is_empty()\r\n}\r\n\r\n/// Split the given path and try to retrieve the\r\n/// session id.\r\nfn session_id_of_path(path: String) -\u003e Option\u003cString\u003e {\r\n    if !path.contains(\"wd/hub/session\") {\r\n        // warning!(\"\");\r\n        return None;\r\n    }\r\n    //check if the path contains the good string\r\n\r\n    // Try to get the session's id part\r\n    // e.g. possible patterns :\r\n    // /wd/hub/session\r\n    // /wd/hub/session/:id\r\n    // /wd/hub/session/:id/:cmd\r\n    let tail: Vec\u003c\u0026str\u003e = path\r\n        .split(\"/wd/hub/session\")\r\n        .filter(|item| !item.is_empty())\r\n        .collect();\r\n\r\n    // if the path contains /url the remainder split the item in the tail at the index 1\r\n    if path.contains(\"/url\") {\r\n        let remainder: Vec\u003c\u0026str\u003e = tail[1].split('/').filter(|s| !s.is_empty()).collect();\r\n        return Some(remainder[0].to_string());\r\n    }\r\n    // Check if there is a remainder with a session's id\r\n    // e.g. possible patterns :\r\n    // /:id\r\n    // /:id/:cmd\r\n    if !tail.is_empty() {\r\n        let remainder: Vec\u003c\u0026str\u003e = tail[0].split('/').filter(|s| !s.is_empty()).collect();\r\n        println!(\"the remainder : {:?}\", remainder);\r\n        return Some(remainder[0].to_string());\r\n    }\r\n\r\n    None\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[tokio::test]\r\n    async fn capture_delete_event_should_return_a_well_formated_log_with_the_session_id() {\r\n        let path = \"/wd/hub/session/123\";\r\n        let delete_event: String = capture_delete_event(path.to_string()).await;\r\n\r\n        let expected_delete_event =\r\n            format!(\"[{}] [{}]\", domain::session::SessionStatus::Deleting, \"123\");\r\n\r\n        assert_eq!(\r\n            delete_event, expected_delete_event,\r\n            \"The delete event log isn't the expected one.\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn session_id_of_path_return_none_when_session_id_is_missing() {\r\n        let path: String = \"/wd/hub/session\".to_string();\r\n        let expected_session = None;\r\n        assert_eq!(session_id_of_path(path), expected_session);\r\n    }\r\n\r\n    #[test]\r\n    fn session_id_of_path_return_some_when_session_id_exists() {\r\n        let path: String = \"/wd/hub/session/123\".to_string();\r\n        assert_eq!(session_id_of_path(path), Some(\"123\".to_string()));\r\n    }\r\n\r\n    #[test]\r\n    fn session_id_of_path_return_none_when_path_is_malformed() {\r\n        let path: String = \"/bad/hub/session/123\".to_string();\r\n        assert_eq!(session_id_of_path(path), None);\r\n    }\r\n\r\n    #[test]\r\n    fn session_id_of_path_return_none_when_there_are_a_command() {\r\n        let path: String =\r\n            \"/wd/hub/session/5ac4bfb5-0978-4b39-9480-0cf126d2665a/screenshot\".to_string();\r\n        assert_eq!(\r\n            session_id_of_path(path),\r\n            Some(\"5ac4bfb5-0978-4b39-9480-0cf126d2665a\".to_string())\r\n        );\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn capture_create_event_return_a_good_format_of_desired_caps() {\r\n        let desired: domain::DesiredCapabilities = domain::DesiredCapabilities {\r\n            browser_name: Some(\"chrome\".to_string()),\r\n            platform: Some(\"LINUX\".to_string()),\r\n            soda_user: Some(\"Tappas\".to_string()),\r\n        };\r\n\r\n        let mock_post_http_request_body = r#\"\r\n        {\r\n            \"capabilities\":{\r\n                \"desiredCapabilities\":{\r\n                    \"soda:user\":\"Tappas\",\r\n                    \"browserName\":\"chrome\",\r\n                    \"testLocal\":\"false\",\r\n                    \"acceptSslCerts\":true,\r\n                    \"platform\":\"LINUX\"\r\n                },\r\n                \"requiredCapabilities\":{\r\n\r\n                }\r\n            },\r\n            \"desiredCapabilities\":{\r\n                \"soda:user\":\"Tappas\",\r\n                \"browserName\":\"chrome\",\r\n                \"testLocal\":\"false\",\r\n                \"acceptSslCerts\":true,\r\n                \"platform\":\"LINUX\"\r\n            },\r\n            \"requiredCapabilities\":{\r\n\r\n            }\r\n        }\"#;\r\n\r\n        let body = Bytes::from(mock_post_http_request_body);\r\n        let desired_caps_result = capture_create_event(\u0026body).await;\r\n\r\n        let expected_desired_caps = CreateEvent {\r\n            event: domain::SessionStatus::Creating,\r\n            desired_capabilities: desired,\r\n        };\r\n\r\n        assert_eq!(desired_caps_result, expected_desired_caps);\r\n\r\n        // let expected = format!(\r\n        //     \"[{}] [{:?}]\",\r\n        //     domain::session::SessionStatus::Creating,\r\n        //     desired,\r\n        // );\r\n        // assert_eq!(desired_caps, expected);\r\n    }\r\n    // #[tokio::test]\r\n    // async fn capture_create_event_return_an_error_when_fail_to_deserialize_the_capabilities() {\r\n    //     let mock_post_http_request_body = r#\"\r\n    //     {\r\n    //         \"capabilities\":{\r\n    //             \"desiredCapabilities\":{\r\n    //                 \"soda:user\":\"\",\r\n    //                 \"browserName\":\"\",\r\n    //                 \"testLocal\":\"false\",\r\n    //                 \"acceptSslCerts\":true,\r\n    //                 \"platform\":\"\"\r\n    //             },\r\n    //             \"requiredCapabilities\":{\r\n\r\n    //             }\r\n    //         },\r\n    //         \"desiredCapabilities\":{\r\n    //             \"soda:user\":\"\",\r\n    //             \"browserName\":\"\",\r\n    //             \"testLocal\":\"false\",\r\n    //             \"acceptSslCerts\":true,\r\n    //             \"platform\":\"\"\r\n    //         },\r\n    //         \"requiredCapabilities\":{\r\n\r\n    //         }\r\n    //     }\"#;\r\n\r\n    //     let body = Bytes::from(mock_post_http_request_body);\r\n    //     let desired_caps_result = capture_create_event(\u0026body).await;\r\n\r\n    //     assert_eq!(desired_caps_result);\r\n    // }\r\n    #[tokio::test]\r\n    async fn capture_delete_event_should_return_an_empty_session_id_when_there_is_an_unexpected_path(\r\n    ) {\r\n        let path = \"/bad/path/session/123\";\r\n\r\n        let delete_event: String = capture_delete_event(path.to_string()).await;\r\n        // test the format of the delete event\r\n\r\n        let expected_delete_event =\r\n            format!(\"[{}] [{}]\", domain::session::SessionStatus::Deleting, \"\");\r\n\r\n        assert_eq!(\r\n            delete_event, expected_delete_event,\r\n            \"The delete event shouldn't contains the session id but an empty string.\"\r\n        );\r\n    }\r\n    #[tokio::test]\r\n    async fn capture_url_event_should_return_session_id_urlcommand_and_session_status() {\r\n        let mock_post_http_request_body = r#\"\r\n        {\r\n            \"url\":\"https://duckduckgo.com/\"\r\n         }\"#;\r\n\r\n        let body = Bytes::from(mock_post_http_request_body);\r\n        let path = \" /wd/hub/session/f52c41e5-3c3f-4cf3-9fe2-963e4a744aa7/url\".to_string();\r\n\r\n        let expected_event = Some(CommandEvent {\r\n            event: domain::session::SessionStatus::UrlCommand,\r\n            session_id: \"f52c41e5-3c3f-4cf3-9fe2-963e4a744aa7\".to_string(),\r\n            url: \"https://duckduckgo.com/\".to_string(),\r\n        });\r\n\r\n        let capture_event = capture_url_event(path, \u0026body);\r\n\r\n        assert_eq!(capture_event, expected_event);\r\n    }\r\n    #[tokio::test]\r\n    async fn capture_create_event_should_return_none_when_the_path_does_not_contain_url() {\r\n        let mock_post_http_request_body = r#\"\r\n        {\r\n            \"url\":\"https://duckduckgo.com/\"\r\n         }\"#;\r\n\r\n        let body = Bytes::from(mock_post_http_request_body);\r\n        let path = \" /wd/hub/session/f52c41e5-3c3f-4cf3-9fe2-963e4a744aa7\".to_string();\r\n\r\n        let capture_event = capture_url_event(path, \u0026body);\r\n\r\n        assert_eq!(capture_event, None);\r\n    }\r\n    #[test]\r\n    fn is_a_new_session_return_splitted_path() {\r\n        let path = \"/wd/hub/session\".to_string();\r\n        assert_eq!(is_a_new_session(\u0026path), true);\r\n    }\r\n    #[test]\r\n    fn is_a_new_session_return_false_when_given_bad_path() {\r\n        let path = \"/wd/hub/session/1234\".to_string();\r\n        assert_eq!(is_a_new_session(\u0026path), false);\r\n    }\r\n}\r\n","traces":[{"line":20,"address":4565024,"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":21,"address":4565041,"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":4565408,"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":27,"address":4565425,"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":4361104,"length":1,"stats":{"Line":0},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":32,"address":4865571,"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":4865597,"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":4865651,"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":4866336,"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":4866356,"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":4361254,"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":4866474,"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":4867740,"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":4361344,"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":4867701,"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":4868970,"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":4869191,"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":4372128,"length":1,"stats":{"Line":5},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":52,"address":4871184,"length":1,"stats":{"Line":3},"fn_name":"{{closure}}"},{"line":54,"address":4871417,"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":4347392,"length":1,"stats":{"Line":3},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":64,"address":4872556,"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":4872016,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":66,"address":4872033,"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":4872239,"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":4872448,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":73,"address":4872702,"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":4565920,"length":1,"stats":{"Line":1},"fn_name":"capture_url_event"},{"line":84,"address":4565935,"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":4566088,"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":4566138,"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":4873089,"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":4873295,"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":4566191,"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":4566199,"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":4566391,"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":4566281,"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":4566289,"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":4566321,"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":4566061,"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":4566688,"length":1,"stats":{"Line":2},"fn_name":"is_a_new_session"},{"line":112,"address":4566712,"length":1,"stats":{"Line":2},"fn_name":null},{"line":114,"address":4873584,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":117,"address":4566795,"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":4566880,"length":1,"stats":{"Line":1},"fn_name":"session_id_of_path"},{"line":123,"address":4566898,"length":1,"stats":{"Line":2},"fn_name":null},{"line":125,"address":4567044,"length":1,"stats":{"Line":2},"fn_name":null},{"line":134,"address":4567019,"length":1,"stats":{"Line":1},"fn_name":null},{"line":136,"address":4873648,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":140,"address":4567180,"length":1,"stats":{"Line":1},"fn_name":null},{"line":141,"address":4567288,"length":1,"stats":{"Line":2},"fn_name":null},{"line":142,"address":4567414,"length":1,"stats":{"Line":1},"fn_name":null},{"line":148,"address":4567262,"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":4567598,"length":1,"stats":{"Line":2},"fn_name":null},{"line":150,"address":4567731,"length":1,"stats":{"Line":1},"fn_name":null},{"line":151,"address":4567895,"length":1,"stats":{"Line":1},"fn_name":null},{"line":154,"address":4567573,"length":1,"stats":{"Line":1},"fn_name":null},{"line":161,"address":4371536,"length":1,"stats":{"Line":4},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":163,"address":4700780,"length":1,"stats":{"Line":1},"fn_name":null},{"line":164,"address":4371594,"length":1,"stats":{"Line":1},"fn_name":null},{"line":167,"address":4701276,"length":1,"stats":{"Line":1},"fn_name":null},{"line":169,"address":4701596,"length":1,"stats":{"Line":1},"fn_name":null},{"line":176,"address":4702768,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":177,"address":4906190,"length":1,"stats":{"Line":1},"fn_name":null},{"line":178,"address":4906208,"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":4906217,"length":1,"stats":{"Line":1},"fn_name":null},{"line":183,"address":4702800,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":184,"address":4906782,"length":1,"stats":{"Line":1},"fn_name":null},{"line":185,"address":4906817,"length":1,"stats":{"Line":1},"fn_name":null},{"line":189,"address":4702832,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":190,"address":4907438,"length":1,"stats":{"Line":1},"fn_name":null},{"line":191,"address":4907473,"length":1,"stats":{"Line":1},"fn_name":null},{"line":195,"address":4702864,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":197,"address":4907998,"length":1,"stats":{"Line":1},"fn_name":null},{"line":198,"address":4908111,"length":1,"stats":{"Line":0},"fn_name":null},{"line":199,"address":4908033,"length":1,"stats":{"Line":1},"fn_name":null},{"line":200,"address":4908084,"length":1,"stats":{"Line":1},"fn_name":null},{"line":204,"address":4366192,"length":1,"stats":{"Line":4},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":206,"address":4702976,"length":1,"stats":{"Line":1},"fn_name":null},{"line":207,"address":4702985,"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":4703041,"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":4703140,"length":1,"stats":{"Line":1},"fn_name":null},{"line":212,"address":4703305,"length":1,"stats":{"Line":1},"fn_name":null},{"line":238,"address":4703332,"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":4366318,"length":1,"stats":{"Line":1},"fn_name":null},{"line":241,"address":4703901,"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":4703820,"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":4703828,"length":1,"stats":{"Line":1},"fn_name":null},{"line":246,"address":4704003,"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":4371968,"length":1,"stats":{"Line":4},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":291,"address":4705116,"length":1,"stats":{"Line":1},"fn_name":null},{"line":293,"address":4372026,"length":1,"stats":{"Line":1},"fn_name":null},{"line":297,"address":4705612,"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":4705932,"length":1,"stats":{"Line":1},"fn_name":null},{"line":304,"address":4366752,"length":1,"stats":{"Line":4},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":306,"address":4707185,"length":1,"stats":{"Line":1},"fn_name":null},{"line":311,"address":4707214,"length":1,"stats":{"Line":1},"fn_name":null},{"line":312,"address":4707240,"length":1,"stats":{"Line":1},"fn_name":null},{"line":314,"address":4707416,"length":1,"stats":{"Line":1},"fn_name":null},{"line":315,"address":4707300,"length":1,"stats":{"Line":1},"fn_name":null},{"line":316,"address":4707308,"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":4707359,"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":4707558,"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":4707651,"length":1,"stats":{"Line":1},"fn_name":null},{"line":324,"address":4362928,"length":1,"stats":{"Line":4},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":326,"address":4708641,"length":1,"stats":{"Line":1},"fn_name":null},{"line":331,"address":4708662,"length":1,"stats":{"Line":1},"fn_name":null},{"line":332,"address":4708688,"length":1,"stats":{"Line":1},"fn_name":null},{"line":334,"address":4708743,"length":1,"stats":{"Line":1},"fn_name":null},{"line":336,"address":4708827,"length":1,"stats":{"Line":1},"fn_name":null},{"line":339,"address":4709616,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":340,"address":4909838,"length":1,"stats":{"Line":1},"fn_name":null},{"line":341,"address":4909878,"length":1,"stats":{"Line":1},"fn_name":null},{"line":344,"address":4709648,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":345,"address":4910382,"length":1,"stats":{"Line":1},"fn_name":null},{"line":346,"address":4910422,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":93,"coverable":116},{"path":["/","mnt","d","devhome","soda-test-service","src","main.rs"],"content":"#[macro_use]\nextern crate serde_derive;\n#[macro_use]\nextern crate log;\n#[macro_use]\nextern crate clap;\n\nuse env_logger;\nuse hyper::service::{make_service_fn, service_fn};\nuse hyper::{Body, Request};\nuse hyper::{Error, Server};\nuse reqwest::Client as HttpClient;\nuse std::net::ToSocketAddrs;\nuse std::time::Duration;\n\nmod cli;\nmod domain;\nmod inspector;\nmod reverse_proxy;\n\npub struct AppState {\n    pub client: HttpClient,\n    pub forward_uri: String,\n}\n\n#[tokio::main]\nasync fn main() {\n    std::env::set_var(\"RUST_LOG\", \"info\");\n    env_logger::init();\n    let matches = cli::init();\n\n    // Configure addresses to listen and forward.\n    let listen = matches.value_of(\"listen\").unwrap();\n    let forwarded = matches.value_of(\"forward\").unwrap();\n    let in_addr = listen.to_socket_addrs().unwrap().next().unwrap();\n    let forward_str = forwarded.to_socket_addrs().unwrap().next().unwrap();\n    // Used to give a more verbose output. (all info logs)\n    let _verbose = matches.occurrences_of(\"verbose\");\n\n    // Configure the timeout for the proxy, default to 60s\n    let timeout = value_t!(matches, \"timeout\", u32).unwrap_or(60);\n\n    let make_svc = make_service_fn(move |_| {\n        async move {\n            Ok::\u003c_, Error\u003e(service_fn(move |req: Request\u003cBody\u003e| {\n                async move {\n                    let state = AppState {\n                        client: HttpClient::builder()\n                            .timeout(Duration::from_secs(timeout.into()))\n                            .build()\n                            .expect(\"Can't create the http client.\"),\n                        forward_uri: forward_str.to_string(),\n                    };\n\n                    reverse_proxy::forward(req, state).await\n                }\n            }))\n        }\n    });\n\n    let server = Server::bind(\u0026in_addr).serve(make_svc);\n\n    info!(\n        \"Server will listen on {} and forward to {}\",\n        listen, forwarded\n    );\n\n    if let Err(e) = server.await {\n        error!(\"server error: {}\", e);\n    }\n}\n","traces":[{"line":26,"address":4340464,"length":1,"stats":{"Line":0},"fn_name":"main"},{"line":29,"address":4407766,"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":4407812,"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":4407829,"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":4407991,"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":4408135,"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":4408337,"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":4408490,"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":4408541,"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":4407552,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":44,"address":4354432,"length":1,"stats":{"Line":0},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":45,"address":4407024,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":46,"address":4377712,"length":1,"stats":{"Line":0},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":47,"address":4405648,"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":4405680,"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":4405729,"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":4405988,"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":4377773,"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":4409300,"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":4409424,"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":4409677,"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":4380772,"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":4410381,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":23},{"path":["/","mnt","d","devhome","soda-test-service","src","reverse_proxy.rs"],"content":"use bytes::Bytes;\r\nuse hyper::{Body, Method, Request, Response};\r\nuse std::net::{SocketAddr, ToSocketAddrs};\r\nuse url::Url;\r\n\r\nuse crate::inspector;\r\nuse crate::AppState;\r\n\r\n#[derive(Debug)]\r\npub struct RequestToInspect\u003c'm, 'b\u003e {\r\n    pub method: \u0026'm Method,\r\n    pub path: String,\r\n    pub body: \u0026'b Bytes,\r\n}\r\n\r\n/// Proxy a Selenium request (from a Selenium client) to the hub.\r\n/// This function also inspect the content in order to write some logs / insights.\r\npub async fn forward(req: Request\u003cBody\u003e, state: AppState) -\u003e Result\u003cResponse\u003cBody\u003e, hyper::Error\u003e {\r\n    let forward_url = state.forward_uri;\r\n    let out_addr: SocketAddr = forward_url.to_socket_addrs().unwrap().next().unwrap();\r\n    let method = req.method().to_owned();\r\n    let path = \u0026req\r\n        .uri()\r\n        .path_and_query()\r\n        .map(|x| x.to_string())\r\n        .unwrap_or_else(|| \"\".to_string());\r\n\r\n    info!(\"{} {}\", method, path);\r\n\r\n    let uri_string = format!(\"http://{}{}\", out_addr, path);\r\n    // todo : handle error\r\n    let url = Url::parse(\u0026uri_string)\r\n        .map_err(|err| error!(\"err : {}\", err))\r\n        .unwrap();\r\n\r\n    let body_bytes = hyper::body::to_bytes(req).await?;\r\n\r\n    let request_to_inspect = RequestToInspect {\r\n        path: String::from(path),\r\n        method: \u0026method,\r\n        body: \u0026body_bytes,\r\n    };\r\n\r\n    inspector::inspect(request_to_inspect).await;\r\n\r\n    // todo : handle errors\r\n    // Recreate a request based on the client http request.\r\n    // We use the body, the method and the url provided from the client.\r\n    // Example : POST /session\r\n    // the path is /session, the method is POST and the data is the request body (bytes).\r\n    // Then we send the the request to the hub and we retrieve the response asynchronously.\r\n    let response = state\r\n        .client\r\n        .request(method, url) // POST http://127.0.0.1:4444/session\r\n        .body(body_bytes)\r\n        .send()\r\n        .await\r\n        .map_err(|err| error!(\"err  for response unwrap : {}\", err))\r\n        .unwrap();\r\n\r\n    // We retrieve the response body as bytes which is useful if we need\r\n    // to deserialize the data. For example if we need to retrieve the\r\n    // session id once a session is created on the hub.\r\n    let response_body = response\r\n        .bytes()\r\n        .await\r\n        .map_err(|err| error!(\"err for response body unwrap : {}\", err))\r\n        .unwrap();\r\n\r\n    // Return the response (from the hub) to the Selenium client.\r\n    Ok(Response::new(Body::from(response_body)))\r\n}\r\n\r\n// #[cfg(test)]\r\n// mod tests {\r\n//     use super::*;\r\n\r\n//     #[tokio::test]\r\n//     async fn forward_a_good_response() {\r\n//         let mock_post_http_request =\r\n//     }\r\n// }\r\n","traces":[{"line":18,"address":4375984,"length":1,"stats":{"Line":0},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":19,"address":4641165,"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":4641201,"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":4641487,"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":4641588,"length":1,"stats":{"Line":0},"fn_name":null},{"line":25,"address":4639648,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":26,"address":4639696,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":28,"address":4641776,"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":4642390,"length":1,"stats":{"Line":0},"fn_name":null},{"line":32,"address":4642730,"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":4639744,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":34,"address":4642910,"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":4376245,"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":4644107,"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":4646316,"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":4644083,"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":4644101,"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":4376464,"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":4376524,"length":1,"stats":{"Line":0},"fn_name":null},{"line":54,"address":4644496,"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":4644691,"length":1,"stats":{"Line":0},"fn_name":null},{"line":58,"address":4640080,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":64,"address":4376549,"length":1,"stats":{"Line":0},"fn_name":null},{"line":67,"address":4640496,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":71,"address":4645747,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":25}]};</script>
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : '')
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + (file.covered / file.coverable * 100).toFixed(2) + '%)' : '')
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const files = data.files.map(file => ({...file, path: file.path.slice(commonPath.length), parent: commonPath}));
  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
  };

  ReactDOM.render(e(App, {root}), document.getElementById('root'));
}());
</script>
</body>
</html>