<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <style>html, body {
  margin: 0;
  padding: 0;
}

.app {
  margin: 10px;
  padding: 0;
}

.files-list {
  margin: 10px 0 0;
  width: 100%;
  border-collapse: collapse;
}
.files-list__head {
  border: 1px solid #999;
}
.files-list__head > tr > th {
  padding: 10px;
  border: 1px solid #999;
  text-align: left;
  font-weight: normal;
  background: #ddd;
}
.files-list__body {
}
.files-list__file {
  cursor: pointer;
}
.files-list__file:hover {
  background: #ccf;
}
.files-list__file > td {
  padding: 10px;
  border: 1px solid #999;
}
.files-list__file > td:first-child::before {
  content: '\01F4C4';
  margin-right: 1em;
}
.files-list__file_low {
  background: #fcc;
}
.files-list__file_medium {
  background: #ffc;
}
.files-list__file_high {
  background: #cfc;
}
.files-list__file_folder > td:first-child::before {
  content: '\01F4C1';
  margin-right: 1em;
}

.file-header {
  border: 1px solid #999;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.file-header__back {
  margin: 10px;
  cursor: pointer;
  flex-shrink: 0;
  flex-grow: 0;
  text-decoration: underline;
  color: #338;
}

.file-header__name {
  margin: 10px;
  flex-shrink: 2;
  flex-grow: 2;
}

.file-header__stat {
  margin: 10px;
  flex-shrink: 0;
  flex-grow: 0;
}

.file-content {
  margin: 10px 0 0;
  border: 1px solid #999;
  padding: 10px;
}

.code-line {
  margin: 0;
  padding: 0.3em;
  height: 1em;
}
.code-line_covered {
  background: #cfc;
}
.code-line_uncovered {
  background: #fcc;
}
</style>
</head>
<body>
    <div id="root"></div>
    <script>var data = {"files":[{"path":["/","mnt","d","devhome","soda-test-service","src","cli","mod.rs"],"content":"use clap::{App, Arg, ArgMatches};\r\n\r\nfn validate_format(v: String) -\u003e Result\u003c(), String\u003e {\r\n    if v.contains(':') {\r\n        return Ok(());\r\n    }\r\n    Err(String::from(\"Format must be IP:PORT\"))\r\n}\r\n\r\npub fn init\u003c'a\u003e() -\u003e ArgMatches\u003c'a\u003e {\r\n    App::new(\"HTTP Proxy\")\r\n        .arg(\r\n            Arg::with_name(\"listen\")\r\n                .long(\"listen\")\r\n                .help(\"format : IP:PORT\")\r\n                .takes_value(true)\r\n                .validator(validate_format)\r\n                .required(true),\r\n        )\r\n        .arg(\r\n            Arg::with_name(\"forward\")\r\n                .long(\"forward\")\r\n                .help(\"format : IP:PORT\")\r\n                .takes_value(true)\r\n                .validator(validate_format)\r\n                .required(true),\r\n        )\r\n        .arg(\r\n            Arg::with_name(\"verbose\")\r\n                .short(\"-v\")\r\n                .long(\"verbose\")\r\n                .multiple(true)\r\n                .help(\"Make the server more talkative\")\r\n                .takes_value(false)\r\n                .required(false),\r\n        )\r\n        .arg(\r\n            Arg::with_name(\"timeout\")\r\n                .long(\"timeout\")\r\n                .help(\"format : DURATION_IN_SECS\")\r\n                .takes_value(true)\r\n                .required(true),\r\n        )\r\n        .get_matches()\r\n}\r\n","traces":[{"line":3,"address":4988144,"length":1,"stats":{"Line":0},"fn_name":"validate_format"},{"line":4,"address":4988156,"length":1,"stats":{"Line":0},"fn_name":null},{"line":5,"address":4988279,"length":1,"stats":{"Line":0},"fn_name":null},{"line":7,"address":4988250,"length":1,"stats":{"Line":0},"fn_name":null},{"line":10,"address":4988368,"length":1,"stats":{"Line":0},"fn_name":"init"},{"line":11,"address":4988391,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":6},{"path":["/","mnt","d","devhome","soda-test-service","src","domain","capabilities.rs"],"content":"use std::fmt;\n#[derive(Debug, Deserialize)]\n#[serde(rename_all = \"camelCase\")]\npub struct Capabilities {\n    pub desired_capabilities: DesiredCapabilities,\n}\n\n#[derive(Debug, Deserialize, Clone, PartialEq)]\n#[serde(rename_all = \"camelCase\")]\npub struct DesiredCapabilities {\n    pub browser_name: Option\u003cString\u003e,\n    pub platform: Option\u003cString\u003e,\n    #[serde(rename(deserialize = \"soda:user\"))]\n    pub soda_user: Option\u003cString\u003e,\n}\n\nimpl DesiredCapabilities {\n    fn new() -\u003e DesiredCapabilities {\n        DesiredCapabilities {\n            browser_name: None,\n            platform: None,\n            soda_user: None,\n        }\n    }\n}\n\nimpl fmt::Display for DesiredCapabilities {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        // Use `self.number` to refer to each positional data point.\n        write!(\n            f,\n            \"(browser: {}, platform: {}, user: {})\",\n            self.browser_name.clone().unwrap_or_else(|| \"\".to_string()),\n            self.platform.clone().unwrap_or_else(|| \"\".to_string()),\n            self.soda_user.clone().unwrap_or_else(|| \"\".to_string())\n        )\n    }\n}\n\nimpl Capabilities {\n    pub fn new() -\u003e Capabilities {\n        Capabilities {\n            desired_capabilities: DesiredCapabilities::new(),\n        }\n    }\n}\n","traces":[{"line":18,"address":4916560,"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":28,"address":4916688,"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":30,"address":4916924,"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":4916705,"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":4721008,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":34,"address":4721056,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":35,"address":4721104,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":41,"address":4917440,"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":43,"address":4917447,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":9},{"path":["/","mnt","d","devhome","soda-test-service","src","domain","command.rs"],"content":"#[derive(Debug, Default, Deserialize)]\r\npub struct Command {\r\n    pub url: Option\u003cString\u003e,\r\n}\r\n\r\nimpl Command {\r\n    pub fn new() -\u003e Command {\r\n        Command {\r\n            url: Some(\"\".to_string()),\r\n        }\r\n    }\r\n\r\n    pub fn url(self) -\u003e String {\r\n        self.url.unwrap_or_else(|| \"\".to_string())\r\n    }\r\n}\r\n","traces":[{"line":7,"address":4533760,"length":1,"stats":{"Line":0},"fn_name":"new"},{"line":9,"address":4533771,"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":4533872,"length":1,"stats":{"Line":1},"fn_name":"url"},{"line":14,"address":4340416,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"}],"covered":2,"coverable":4},{"path":["/","mnt","d","devhome","soda-test-service","src","domain","session.rs"],"content":"use std::fmt;\n\n#[derive(Debug, PartialEq)]\npub enum SessionStatus {\n    Creating,\n    UrlCommand,\n    Deleting,\n}\n\nimpl fmt::Display for SessionStatus {\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\n        match *self {\n            SessionStatus::Creating =\u003e write!(f, \"SESSION_CREATING\"),\n            SessionStatus::UrlCommand =\u003e write!(f, \"SESSION_URL_COMMAND\"),\n            SessionStatus::Deleting =\u003e write!(f, \"SESSION_DELETING\"),\n        }\n    }\n}\n","traces":[{"line":11,"address":4616688,"length":1,"stats":{"Line":1},"fn_name":"fmt"},{"line":12,"address":4616800,"length":1,"stats":{"Line":0},"fn_name":null},{"line":13,"address":4616705,"length":1,"stats":{"Line":1},"fn_name":null},{"line":14,"address":4616886,"length":1,"stats":{"Line":0},"fn_name":null},{"line":15,"address":4616756,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":3,"coverable":5},{"path":["/","mnt","d","devhome","soda-test-service","src","inspector.rs"],"content":"use crate::domain;\r\nuse crate::reverse_proxy;\r\nuse bytes::Bytes;\r\nuse hyper::Method;\r\nuse std::fmt;\r\n\r\n#[derive(Debug, PartialEq)]\r\nstruct CreateEvent {\r\n    event: domain::session::SessionStatus,\r\n    desired_capabilities: domain::DesiredCapabilities,\r\n}\r\n#[derive(Debug, PartialEq)]\r\nstruct CommandEvent {\r\n    event: domain::session::SessionStatus,\r\n    session_id: String,\r\n    url: String,\r\n}\r\n\r\nimpl fmt::Display for CommandEvent {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        write!(f, \"({},{},{})\", self.event, self.session_id, self.url)\r\n    }\r\n}\r\n\r\nimpl fmt::Display for CreateEvent {\r\n    fn fmt(\u0026self, f: \u0026mut fmt::Formatter) -\u003e fmt::Result {\r\n        write!(f, \"({},{})\", self.event, self.desired_capabilities)\r\n    }\r\n}\r\n\r\npub async fn inspect\u003c'm, 'b\u003e(request: reverse_proxy::RequestToInspect\u003c'm, 'b\u003e) {\r\n    let method = request.method.to_owned();\r\n    let path = request.path;\r\n\r\n    info!(\"Inspecting the request {} {}\", method, path);\r\n\r\n    let body = request.body;\r\n\r\n    if method == Method::DELETE {\r\n        info!(\"{}\", capture_delete_event(path).await);\r\n    } else if method == Method::POST \u0026\u0026 is_a_new_session(\u0026path) {\r\n        println!(\"voici le path pour la new session : {} \", path);\r\n        info!(\"{}\", capture_create_event(body).await);\r\n    } else if method == \"POST\" \u0026\u0026 !is_a_new_session(\u0026path) {\r\n        if let Some(url_event) = capture_url_event(path, body) {\r\n            info!(\"{}\", url_event);\r\n        }\r\n    }\r\n}\r\n\r\nasync fn capture_delete_event(path: String) -\u003e String {\r\n    let session_id = session_id_of_path(path).unwrap_or_else(|| \"\".to_string());\r\n\r\n    format!(\r\n        \"[{}] [{}]\",\r\n        domain::session::SessionStatus::Deleting,\r\n        session_id\r\n    )\r\n    // user IP/ID | session status | session ID\r\n}\r\n\r\n/// Capture new sessions events\r\nasync fn capture_create_event(body: \u0026Bytes) -\u003e CreateEvent {\r\n    let capabilities: domain::Capabilities = serde_json::from_slice(body)\r\n        .map_err(|_| {\r\n            error!(\r\n                \"Fail to deserialize the capabilities for the given payload : {:?}\",\r\n                body\r\n            );\r\n        })\r\n        .unwrap_or_else(|_| domain::Capabilities::new());\r\n\r\n    let desired_capabilities = capabilities.desired_capabilities;\r\n\r\n    CreateEvent {\r\n        event: domain::session::SessionStatus::Creating,\r\n        desired_capabilities,\r\n    }\r\n    //status session pass to creating  user IP/ID | session status | Platform | Browser\r\n}\r\n\r\n/// Capture asked url events\r\nfn capture_url_event(path: String, body: \u0026Bytes) -\u003e Option\u003cCommandEvent\u003e {\r\n    if path.contains(\"/url\") {\r\n        let command: domain::Command = serde_json::from_slice(body)\r\n            .map_err(|_| {\r\n                error!(\r\n                    \"Fail to deserialize the capabilities for the given payload : {:?}\",\r\n                    body\r\n                );\r\n            })\r\n            .unwrap_or_else(|_| domain::Command::new());\r\n\r\n        let session = session_id_of_path(path).unwrap_or_else(|| \"\".to_string());\r\n\r\n        // user IP/ID | session_status | session ID | url_command | url\r\n        return Some(CommandEvent {\r\n            event: domain::session::SessionStatus::UrlCommand,\r\n            session_id: session,\r\n            url: command.url(),\r\n        });\r\n    }\r\n\r\n    None\r\n}\r\n/// Split the path to determine if it's a new session\r\n/// (the path doesn't contain the session's id) or if it's\r\n/// an existing session (the path contains the session's id).\r\n/// If the head and the tail of the path are empty,\r\n/// it's a new session event that we want to capture.\r\nfn is_a_new_session(path: \u0026str) -\u003e bool {\r\n    let splitted_path: Vec\u003c\u0026str\u003e = path\r\n        .split(\"/wd/hub/session\")\r\n        .filter(|item| !item.is_empty())\r\n        .collect();\r\n\r\n    splitted_path.is_empty()\r\n}\r\n\r\n/// Split the given path and try to retrieve the\r\n/// session id.\r\nfn session_id_of_path(path: String) -\u003e Option\u003cString\u003e {\r\n    // we need to verify if the path is to good format\r\n    if !path.contains(\"wd/hub/session\") {\r\n        // warning!(\"\");\r\n        return None;\r\n    }\r\n    //check if the path contains the good string\r\n\r\n    // Try to get the session's id part\r\n    // e.g. possible patterns :\r\n    // /wd/hub/session\r\n    // /wd/hub/session/:id\r\n    // /wd/hub/session/:id/:cmd\r\n    let tail: Vec\u003c\u0026str\u003e = path\r\n        .split(\"/wd/hub/session\")\r\n        .filter(|item| !item.is_empty())\r\n        .collect();\r\n\r\n    // if the path contains /url the remainder split the item in the tail at the index 1\r\n    if path.contains(\"/url\") {\r\n        let remainder: Vec\u003c\u0026str\u003e = tail[1].split('/').filter(|s| !s.is_empty()).collect();\r\n        return Some(remainder[0].to_string());\r\n    }\r\n    // Check if there is a remainder with a session's id\r\n    // e.g. possible patterns :\r\n    // /:id\r\n    // /:id/:cmd\r\n    if !tail.is_empty() {\r\n        let remainder: Vec\u003c\u0026str\u003e = tail[0].split('/').filter(|s| !s.is_empty()).collect();\r\n        println!(\"the remainder : {:?}\", remainder);\r\n        return Some(remainder[0].to_string());\r\n    }\r\n\r\n    None\r\n}\r\n\r\n#[cfg(test)]\r\nmod tests {\r\n    use super::*;\r\n\r\n    #[tokio::test]\r\n    async fn capture_delete_event_should_return_a_well_formated_log_with_the_session_id() {\r\n        let path = \"/wd/hub/session/123\";\r\n        let delete_event: String = capture_delete_event(path.to_string()).await;\r\n\r\n        let expected_delete_event =\r\n            format!(\"[{}] [{}]\", domain::session::SessionStatus::Deleting, \"123\");\r\n\r\n        assert_eq!(\r\n            delete_event, expected_delete_event,\r\n            \"The delete event log isn't the expected one.\"\r\n        );\r\n    }\r\n\r\n    #[test]\r\n    fn session_id_of_path_return_none_when_session_id_is_missing() {\r\n        let path: String = \"/wd/hub/session\".to_string();\r\n        let expected_session = None;\r\n        assert_eq!(session_id_of_path(path), expected_session);\r\n    }\r\n\r\n    #[test]\r\n    fn session_id_of_path_return_some_when_session_id_exists() {\r\n        let path: String = \"/wd/hub/session/123\".to_string();\r\n        assert_eq!(session_id_of_path(path), Some(\"123\".to_string()));\r\n    }\r\n\r\n    #[test]\r\n    fn session_id_of_path_return_none_when_path_is_malformed() {\r\n        let path: String = \"/bad/hub/session/123\".to_string();\r\n        assert_eq!(session_id_of_path(path), None);\r\n    }\r\n\r\n    #[test]\r\n    fn session_id_of_path_return_none_when_there_are_a_command() {\r\n        let path: String =\r\n            \"/wd/hub/session/5ac4bfb5-0978-4b39-9480-0cf126d2665a/screenshot\".to_string();\r\n        assert_eq!(\r\n            session_id_of_path(path),\r\n            Some(\"5ac4bfb5-0978-4b39-9480-0cf126d2665a\".to_string())\r\n        );\r\n    }\r\n\r\n    #[tokio::test]\r\n    async fn capture_create_event_return_a_good_format_of_desired_caps() {\r\n        let desired: domain::DesiredCapabilities = domain::DesiredCapabilities {\r\n            browser_name: Some(\"chrome\".to_string()),\r\n            platform: Some(\"LINUX\".to_string()),\r\n            soda_user: Some(\"Tappas\".to_string()),\r\n        };\r\n\r\n        let mock_post_http_request_body = r#\"\r\n        {\r\n            \"capabilities\":{\r\n                \"desiredCapabilities\":{\r\n                    \"soda:user\":\"Tappas\",\r\n                    \"browserName\":\"chrome\",\r\n                    \"testLocal\":\"false\",\r\n                    \"acceptSslCerts\":true,\r\n                    \"platform\":\"LINUX\"\r\n                },\r\n                \"requiredCapabilities\":{\r\n\r\n                }\r\n            },\r\n            \"desiredCapabilities\":{\r\n                \"soda:user\":\"Tappas\",\r\n                \"browserName\":\"chrome\",\r\n                \"testLocal\":\"false\",\r\n                \"acceptSslCerts\":true,\r\n                \"platform\":\"LINUX\"\r\n            },\r\n            \"requiredCapabilities\":{\r\n\r\n            }\r\n        }\"#;\r\n\r\n        let body = Bytes::from(mock_post_http_request_body);\r\n        let desired_caps_result = capture_create_event(\u0026body).await;\r\n\r\n        let expected_desired_caps = CreateEvent {\r\n            event: domain::SessionStatus::Creating,\r\n            desired_capabilities: desired,\r\n        };\r\n\r\n        assert_eq!(desired_caps_result, expected_desired_caps);\r\n    }\r\n    #[tokio::test]\r\n    async fn capture_create_event_return_an_empty_capabilitie_when_fail_to_deserialize_the_capabilities(\r\n    ) {\r\n        let mock_post_http_request_body = r#\"\r\n        {\r\n            \"capabilities\":{\r\n                \"desiredCapabilities\":{\r\n                    \"soda:user\":\"\",\r\n                    \"browserName\":\"\",\r\n                    \"testLocal\":\"false\",\r\n                    \"acceptSslCerts\":true,\r\n                    \"platform\":\"\"\r\n                },\r\n                \"requiredCapabilities\":{\r\n\r\n                }\r\n            },\r\n            \"desiredCapabilities\":{\r\n                \"soda:user\":\"\",\r\n                \"browserName\":\"\",\r\n                \"testLocal\":\"false\",\r\n                \"acceptSslCerts\":true,\r\n                \"platform\":\"\"\r\n            },\r\n            \"requiredCapabilities\":{\r\n\r\n            }\r\n        }\"#;\r\n\r\n        let body = Bytes::from(mock_post_http_request_body);\r\n        let desired_caps_result = capture_create_event(\u0026body).await;\r\n\r\n        let desired: domain::DesiredCapabilities = domain::DesiredCapabilities {\r\n            browser_name: Some(\"\".to_string()),\r\n            platform: Some(\"\".to_string()),\r\n            soda_user: Some(\"\".to_string()),\r\n        };\r\n\r\n        let expected_desired_caps = CreateEvent {\r\n            event: domain::SessionStatus::Creating,\r\n            desired_capabilities: desired,\r\n        };\r\n\r\n        assert_eq!(desired_caps_result, expected_desired_caps);\r\n    }\r\n    #[tokio::test]\r\n    async fn capture_delete_event_should_return_an_empty_session_id_when_there_is_an_unexpected_path(\r\n    ) {\r\n        let path = \"/bad/path/session/123\";\r\n\r\n        let delete_event: String = capture_delete_event(path.to_string()).await;\r\n        // test the format of the delete event\r\n\r\n        let expected_delete_event =\r\n            format!(\"[{}] [{}]\", domain::session::SessionStatus::Deleting, \"\");\r\n\r\n        assert_eq!(\r\n            delete_event, expected_delete_event,\r\n            \"The delete event shouldn't contains the session id but an empty string.\"\r\n        );\r\n    }\r\n    #[tokio::test]\r\n    async fn capture_url_event_should_return_session_id_urlcommand_and_session_status() {\r\n        let mock_post_http_request_body = r#\"\r\n        {\r\n            \"url\":\"https://duckduckgo.com/\"\r\n         }\"#;\r\n\r\n        let body = Bytes::from(mock_post_http_request_body);\r\n        let path = \" /wd/hub/session/f52c41e5-3c3f-4cf3-9fe2-963e4a744aa7/url\".to_string();\r\n\r\n        let expected_event = Some(CommandEvent {\r\n            event: domain::session::SessionStatus::UrlCommand,\r\n            session_id: \"f52c41e5-3c3f-4cf3-9fe2-963e4a744aa7\".to_string(),\r\n            url: \"https://duckduckgo.com/\".to_string(),\r\n        });\r\n\r\n        let capture_event = capture_url_event(path, \u0026body);\r\n\r\n        assert_eq!(capture_event, expected_event);\r\n    }\r\n    #[tokio::test]\r\n    async fn capture_create_event_should_return_none_when_the_path_does_not_contain_url() {\r\n        let mock_post_http_request_body = r#\"\r\n        {\r\n            \"url\":\"https://duckduckgo.com/\"\r\n         }\"#;\r\n\r\n        let body = Bytes::from(mock_post_http_request_body);\r\n        let path = \" /wd/hub/session/f52c41e5-3c3f-4cf3-9fe2-963e4a744aa7\".to_string();\r\n\r\n        let capture_event = capture_url_event(path, \u0026body);\r\n\r\n        assert_eq!(capture_event, None);\r\n    }\r\n    #[test]\r\n    fn is_a_new_session_return_splitted_path() {\r\n        let path = \"/wd/hub/session\".to_string();\r\n        assert_eq!(is_a_new_session(\u0026path), true);\r\n    }\r\n    #[test]\r\n    fn is_a_new_session_return_false_when_given_bad_path() {\r\n        let path = \"/wd/hub/session/1234\".to_string();\r\n        assert_eq!(is_a_new_session(\u0026path), false);\r\n    }\r\n}\r\n","traces":[{"line":20,"address":4570992,"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":21,"address":4571009,"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":4571376,"length":1,"stats":{"Line":0},"fn_name":"fmt"},{"line":27,"address":4571393,"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":4364352,"length":1,"stats":{"Line":0},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":32,"address":4879091,"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":4879117,"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":4879171,"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":4879856,"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":4879876,"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":4364502,"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":4879994,"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":4881260,"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":4364592,"length":1,"stats":{"Line":0},"fn_name":null},{"line":44,"address":4881221,"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":4882490,"length":1,"stats":{"Line":0},"fn_name":null},{"line":46,"address":4882711,"length":1,"stats":{"Line":0},"fn_name":null},{"line":51,"address":4375632,"length":1,"stats":{"Line":3},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":52,"address":4884704,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":54,"address":4884937,"length":1,"stats":{"Line":1},"fn_name":null},{"line":63,"address":4350512,"length":1,"stats":{"Line":3},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":64,"address":4886076,"length":1,"stats":{"Line":1},"fn_name":null},{"line":65,"address":4885536,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":66,"address":4885553,"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":4885759,"length":1,"stats":{"Line":0},"fn_name":null},{"line":71,"address":4885968,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":73,"address":4886222,"length":1,"stats":{"Line":1},"fn_name":null},{"line":83,"address":4571888,"length":1,"stats":{"Line":1},"fn_name":"capture_url_event"},{"line":84,"address":4571903,"length":1,"stats":{"Line":1},"fn_name":null},{"line":85,"address":4572056,"length":1,"stats":{"Line":1},"fn_name":null},{"line":86,"address":4572106,"length":1,"stats":{"Line":1},"fn_name":null},{"line":87,"address":4886609,"length":1,"stats":{"Line":0},"fn_name":null},{"line":89,"address":4886815,"length":1,"stats":{"Line":0},"fn_name":null},{"line":92,"address":4572159,"length":1,"stats":{"Line":1},"fn_name":null},{"line":94,"address":4572167,"length":1,"stats":{"Line":1},"fn_name":null},{"line":97,"address":4572359,"length":1,"stats":{"Line":1},"fn_name":null},{"line":98,"address":4572249,"length":1,"stats":{"Line":1},"fn_name":null},{"line":99,"address":4572257,"length":1,"stats":{"Line":1},"fn_name":null},{"line":100,"address":4572289,"length":1,"stats":{"Line":1},"fn_name":null},{"line":104,"address":4572029,"length":1,"stats":{"Line":1},"fn_name":null},{"line":111,"address":4572656,"length":1,"stats":{"Line":1},"fn_name":"is_a_new_session"},{"line":112,"address":4572680,"length":1,"stats":{"Line":1},"fn_name":null},{"line":114,"address":4887104,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":117,"address":4572763,"length":1,"stats":{"Line":2},"fn_name":null},{"line":122,"address":4572848,"length":1,"stats":{"Line":1},"fn_name":"session_id_of_path"},{"line":124,"address":4572866,"length":1,"stats":{"Line":1},"fn_name":null},{"line":126,"address":4573012,"length":1,"stats":{"Line":1},"fn_name":null},{"line":135,"address":4572987,"length":1,"stats":{"Line":1},"fn_name":null},{"line":137,"address":4887168,"length":1,"stats":{"Line":1},"fn_name":"{{closure}}"},{"line":141,"address":4573148,"length":1,"stats":{"Line":1},"fn_name":null},{"line":142,"address":4573256,"length":1,"stats":{"Line":2},"fn_name":null},{"line":143,"address":4573382,"length":1,"stats":{"Line":1},"fn_name":null},{"line":149,"address":4573230,"length":1,"stats":{"Line":1},"fn_name":null},{"line":150,"address":4573566,"length":1,"stats":{"Line":2},"fn_name":null},{"line":151,"address":4573699,"length":1,"stats":{"Line":1},"fn_name":null},{"line":152,"address":4573863,"length":1,"stats":{"Line":1},"fn_name":null},{"line":155,"address":4573541,"length":1,"stats":{"Line":1},"fn_name":null},{"line":162,"address":4375040,"length":1,"stats":{"Line":4},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":164,"address":4709676,"length":1,"stats":{"Line":1},"fn_name":null},{"line":165,"address":4375098,"length":1,"stats":{"Line":1},"fn_name":null},{"line":168,"address":4710172,"length":1,"stats":{"Line":1},"fn_name":null},{"line":170,"address":4710492,"length":1,"stats":{"Line":1},"fn_name":null},{"line":177,"address":4711664,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":178,"address":4919886,"length":1,"stats":{"Line":1},"fn_name":null},{"line":179,"address":4919904,"length":1,"stats":{"Line":1},"fn_name":null},{"line":180,"address":4919913,"length":1,"stats":{"Line":1},"fn_name":null},{"line":184,"address":4711696,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":185,"address":4920478,"length":1,"stats":{"Line":1},"fn_name":null},{"line":186,"address":4920513,"length":1,"stats":{"Line":1},"fn_name":null},{"line":190,"address":4711728,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":191,"address":4921134,"length":1,"stats":{"Line":1},"fn_name":null},{"line":192,"address":4921169,"length":1,"stats":{"Line":1},"fn_name":null},{"line":196,"address":4711760,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":198,"address":4921694,"length":1,"stats":{"Line":1},"fn_name":null},{"line":199,"address":4921807,"length":1,"stats":{"Line":0},"fn_name":null},{"line":200,"address":4921729,"length":1,"stats":{"Line":1},"fn_name":null},{"line":201,"address":4921780,"length":1,"stats":{"Line":1},"fn_name":null},{"line":205,"address":4369504,"length":1,"stats":{"Line":4},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":207,"address":4711872,"length":1,"stats":{"Line":1},"fn_name":null},{"line":208,"address":4711881,"length":1,"stats":{"Line":1},"fn_name":null},{"line":209,"address":4711937,"length":1,"stats":{"Line":1},"fn_name":null},{"line":210,"address":4712036,"length":1,"stats":{"Line":1},"fn_name":null},{"line":213,"address":4712201,"length":1,"stats":{"Line":1},"fn_name":null},{"line":239,"address":4712228,"length":1,"stats":{"Line":1},"fn_name":null},{"line":240,"address":4369630,"length":1,"stats":{"Line":1},"fn_name":null},{"line":242,"address":4712797,"length":1,"stats":{"Line":1},"fn_name":null},{"line":243,"address":4712716,"length":1,"stats":{"Line":1},"fn_name":null},{"line":244,"address":4712724,"length":1,"stats":{"Line":1},"fn_name":null},{"line":247,"address":4712899,"length":1,"stats":{"Line":1},"fn_name":null},{"line":249,"address":4373968,"length":1,"stats":{"Line":4},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":252,"address":4714000,"length":1,"stats":{"Line":1},"fn_name":null},{"line":278,"address":4714024,"length":1,"stats":{"Line":1},"fn_name":null},{"line":279,"address":4374041,"length":1,"stats":{"Line":1},"fn_name":null},{"line":281,"address":4714668,"length":1,"stats":{"Line":1},"fn_name":null},{"line":282,"address":4714453,"length":1,"stats":{"Line":1},"fn_name":null},{"line":283,"address":4714531,"length":1,"stats":{"Line":1},"fn_name":null},{"line":284,"address":4714593,"length":1,"stats":{"Line":1},"fn_name":null},{"line":287,"address":4714852,"length":1,"stats":{"Line":1},"fn_name":null},{"line":288,"address":4714764,"length":1,"stats":{"Line":1},"fn_name":null},{"line":289,"address":4714772,"length":1,"stats":{"Line":1},"fn_name":null},{"line":292,"address":4714954,"length":1,"stats":{"Line":1},"fn_name":null},{"line":294,"address":4375472,"length":1,"stats":{"Line":4},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":297,"address":4716044,"length":1,"stats":{"Line":1},"fn_name":null},{"line":299,"address":4375530,"length":1,"stats":{"Line":1},"fn_name":null},{"line":303,"address":4716540,"length":1,"stats":{"Line":1},"fn_name":null},{"line":305,"address":4716860,"length":1,"stats":{"Line":1},"fn_name":null},{"line":310,"address":4370064,"length":1,"stats":{"Line":4},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":312,"address":4718113,"length":1,"stats":{"Line":1},"fn_name":null},{"line":317,"address":4718142,"length":1,"stats":{"Line":1},"fn_name":null},{"line":318,"address":4718168,"length":1,"stats":{"Line":1},"fn_name":null},{"line":320,"address":4718344,"length":1,"stats":{"Line":1},"fn_name":null},{"line":321,"address":4718228,"length":1,"stats":{"Line":1},"fn_name":null},{"line":322,"address":4718236,"length":1,"stats":{"Line":1},"fn_name":null},{"line":323,"address":4718287,"length":1,"stats":{"Line":1},"fn_name":null},{"line":326,"address":4718486,"length":1,"stats":{"Line":1},"fn_name":null},{"line":328,"address":4718579,"length":1,"stats":{"Line":1},"fn_name":null},{"line":330,"address":4366208,"length":1,"stats":{"Line":4},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":332,"address":4719569,"length":1,"stats":{"Line":1},"fn_name":null},{"line":337,"address":4719590,"length":1,"stats":{"Line":1},"fn_name":null},{"line":338,"address":4719616,"length":1,"stats":{"Line":1},"fn_name":null},{"line":340,"address":4719671,"length":1,"stats":{"Line":1},"fn_name":null},{"line":342,"address":4719755,"length":1,"stats":{"Line":1},"fn_name":null},{"line":345,"address":4720544,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":346,"address":4923822,"length":1,"stats":{"Line":1},"fn_name":null},{"line":347,"address":4923862,"length":1,"stats":{"Line":1},"fn_name":null},{"line":350,"address":4720576,"length":1,"stats":{"Line":2},"fn_name":"{{closure}}"},{"line":351,"address":4924366,"length":1,"stats":{"Line":1},"fn_name":null},{"line":352,"address":4924406,"length":1,"stats":{"Line":1},"fn_name":null}],"covered":105,"coverable":128},{"path":["/","mnt","d","devhome","soda-test-service","src","main.rs"],"content":"#[macro_use]\nextern crate serde_derive;\n#[macro_use]\nextern crate log;\n#[macro_use]\nextern crate clap;\n\nuse env_logger;\nuse hyper::service::{make_service_fn, service_fn};\nuse hyper::{Body, Request};\nuse hyper::{Error, Server};\nuse reqwest::Client as HttpClient;\nuse std::net::ToSocketAddrs;\nuse std::time::Duration;\n\nmod cli;\nmod domain;\nmod inspector;\nmod reverse_proxy;\n\npub struct AppState {\n    pub client: HttpClient,\n    pub forward_uri: String,\n}\n\n#[tokio::main]\nasync fn main() {\n    std::env::set_var(\"RUST_LOG\", \"info\");\n    env_logger::init();\n    let matches = cli::init();\n\n    // Configure addresses to listen and forward.\n    let listen = matches.value_of(\"listen\").unwrap();\n    let forwarded = matches.value_of(\"forward\").unwrap();\n    let in_addr = listen.to_socket_addrs().unwrap().next().unwrap();\n    let forward_str = forwarded.to_socket_addrs().unwrap().next().unwrap();\n    // Used to give a more verbose output. (all info logs)\n    let _verbose = matches.occurrences_of(\"verbose\");\n\n    // Configure the timeout for the proxy, default to 60s\n    let timeout = value_t!(matches, \"timeout\", u32).unwrap_or(60);\n\n    let make_svc = make_service_fn(move |_| {\n        async move {\n            Ok::\u003c_, Error\u003e(service_fn(move |req: Request\u003cBody\u003e| {\n                async move {\n                    let state = AppState {\n                        client: HttpClient::builder()\n                            .timeout(Duration::from_secs(timeout.into()))\n                            .build()\n                            .expect(\"Can't create the http client.\"),\n                        forward_uri: forward_str.to_string(),\n                    };\n\n                    reverse_proxy::forward(req, state).await\n                }\n            }))\n        }\n    });\n\n    let server = Server::bind(\u0026in_addr).serve(make_svc);\n\n    info!(\n        \"Server will listen on {} and forward to {}\",\n        listen, forwarded\n    );\n\n    if let Err(e) = server.await {\n        error!(\"server error: {}\", e);\n    }\n}\n","traces":[{"line":26,"address":4343504,"length":1,"stats":{"Line":0},"fn_name":"main"},{"line":29,"address":4411366,"length":1,"stats":{"Line":0},"fn_name":null},{"line":30,"address":4411412,"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":4411429,"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":4411591,"length":1,"stats":{"Line":0},"fn_name":null},{"line":35,"address":4411735,"length":1,"stats":{"Line":0},"fn_name":null},{"line":36,"address":4411937,"length":1,"stats":{"Line":0},"fn_name":null},{"line":38,"address":4412090,"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":4412141,"length":1,"stats":{"Line":0},"fn_name":null},{"line":43,"address":4411152,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":44,"address":4357680,"length":1,"stats":{"Line":0},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":45,"address":4410640,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":46,"address":4381248,"length":1,"stats":{"Line":0},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":47,"address":4409222,"length":1,"stats":{"Line":0},"fn_name":null},{"line":48,"address":4409260,"length":1,"stats":{"Line":0},"fn_name":null},{"line":49,"address":4409312,"length":1,"stats":{"Line":0},"fn_name":null},{"line":52,"address":4409577,"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":4381309,"length":1,"stats":{"Line":0},"fn_name":null},{"line":61,"address":4412900,"length":1,"stats":{"Line":0},"fn_name":null},{"line":63,"address":4413024,"length":1,"stats":{"Line":0},"fn_name":null},{"line":65,"address":4413277,"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":4384340,"length":1,"stats":{"Line":0},"fn_name":null},{"line":69,"address":4413981,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":23},{"path":["/","mnt","d","devhome","soda-test-service","src","reverse_proxy.rs"],"content":"use bytes::Bytes;\r\nuse hyper::{Body, Method, Request, Response};\r\nuse std::net::{SocketAddr, ToSocketAddrs};\r\nuse url::Url;\r\n\r\nuse crate::inspector;\r\nuse crate::AppState;\r\n\r\n#[derive(Debug)]\r\npub struct RequestToInspect\u003c'm, 'b\u003e {\r\n    pub method: \u0026'm Method,\r\n    pub path: String,\r\n    pub body: \u0026'b Bytes,\r\n}\r\n\r\n/// Proxy a Selenium request (from a Selenium client) to the hub.\r\n/// This function also inspect the content in order to write some logs / insights.\r\npub async fn forward(req: Request\u003cBody\u003e, state: AppState) -\u003e Result\u003cResponse\u003cBody\u003e, hyper::Error\u003e {\r\n    println!(\"ceci est la requete: {:?}\", req);\r\n    let forward_url = state.forward_uri;\r\n    let out_addr: SocketAddr = forward_url.to_socket_addrs().unwrap().next().unwrap();\r\n    let method = req.method().to_owned();\r\n    let path = \u0026req\r\n        .uri()\r\n        .path_and_query()\r\n        .map(|x| x.to_string())\r\n        .unwrap_or_else(|| \"\".to_string());\r\n\r\n    info!(\"{} {}\", method, path);\r\n\r\n    let uri_string = format!(\"http://{}{}\", out_addr, path);\r\n    // todo : handle error\r\n    let url = Url::parse(\u0026uri_string)\r\n        .map_err(|err| error!(\"err : {}\", err))\r\n        .unwrap();\r\n\r\n    let body_bytes = hyper::body::to_bytes(req).await?;\r\n\r\n    let request_to_inspect = RequestToInspect {\r\n        path: String::from(path),\r\n        method: \u0026method,\r\n        body: \u0026body_bytes,\r\n    };\r\n\r\n    inspector::inspect(request_to_inspect).await;\r\n\r\n    // todo : handle errors\r\n    // Recreate a request based on the client http request.\r\n    // We use the body, the method and the url provided from the client.\r\n    // Example : POST /session\r\n    // the path is /session, the method is POST and the data is the request body (bytes).\r\n    // Then we send the the request to the hub and we retrieve the response asynchronously.\r\n    let response = state\r\n        .client\r\n        .request(method, url) // POST http://127.0.0.1:4444/session\r\n        .body(body_bytes)\r\n        .send()\r\n        .await\r\n        .map_err(|err| error!(\"err  for response unwrap : {}\", err))\r\n        .unwrap();\r\n\r\n    // We retrieve the response body as bytes which is useful if we need\r\n    // to deserialize the data. For example if we need to retrieve the\r\n    // session id once a session is created on the hub.\r\n    let response_body = response\r\n        .bytes()\r\n        .await\r\n        .map_err(|err| error!(\"err for response body unwrap : {}\", err))\r\n        .unwrap();\r\n\r\n    // Return the response (from the hub) to the Selenium client.\r\n    Ok(Response::new(Body::from(response_body)))\r\n}\r\n","traces":[{"line":18,"address":4379488,"length":1,"stats":{"Line":0},"fn_name":"real_drop_in_place\u003cgenerator-0\u003e"},{"line":19,"address":4649691,"length":1,"stats":{"Line":0},"fn_name":null},{"line":20,"address":4649987,"length":1,"stats":{"Line":0},"fn_name":null},{"line":21,"address":4650038,"length":1,"stats":{"Line":0},"fn_name":null},{"line":22,"address":4650223,"length":1,"stats":{"Line":0},"fn_name":null},{"line":23,"address":4650324,"length":1,"stats":{"Line":0},"fn_name":null},{"line":26,"address":4648144,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":27,"address":4648192,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":29,"address":4650512,"length":1,"stats":{"Line":0},"fn_name":null},{"line":31,"address":4651126,"length":1,"stats":{"Line":0},"fn_name":null},{"line":33,"address":4651466,"length":1,"stats":{"Line":0},"fn_name":null},{"line":34,"address":4648240,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":35,"address":4651646,"length":1,"stats":{"Line":0},"fn_name":null},{"line":37,"address":4379759,"length":1,"stats":{"Line":0},"fn_name":null},{"line":39,"address":4652843,"length":1,"stats":{"Line":0},"fn_name":null},{"line":40,"address":4655136,"length":1,"stats":{"Line":0},"fn_name":null},{"line":41,"address":4652819,"length":1,"stats":{"Line":0},"fn_name":null},{"line":42,"address":4652837,"length":1,"stats":{"Line":0},"fn_name":null},{"line":45,"address":4379978,"length":1,"stats":{"Line":0},"fn_name":null},{"line":53,"address":4380038,"length":1,"stats":{"Line":0},"fn_name":null},{"line":55,"address":4653232,"length":1,"stats":{"Line":0},"fn_name":null},{"line":56,"address":4653427,"length":1,"stats":{"Line":0},"fn_name":null},{"line":59,"address":4648576,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":65,"address":4380063,"length":1,"stats":{"Line":0},"fn_name":null},{"line":68,"address":4648992,"length":1,"stats":{"Line":0},"fn_name":"{{closure}}"},{"line":72,"address":4654483,"length":1,"stats":{"Line":0},"fn_name":null}],"covered":0,"coverable":26}]};</script>
    <script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"></script>
    <script>const e = React.createElement;

function pathToString(path) {
  if (path[0] === '/') {
    return '/' + path.slice(1).join('/');
  } else {
    return path.join('/');
  }
}

function findCommonPath(files) {
  if (!files || !files.length) {
    return [];
  }

  function isPrefix(arr, prefix) {
    if (arr.length < prefix.length) {
      return false;
    }
    for (let i = prefix.length - 1; i >= 0; --i) {
      if (arr[i] !== prefix[i]) {
        return false;
      }
    }
    return true;
  }

  let commonPath = files[0].path.slice(0, -1);
  while (commonPath.length) {
    if (files.every(file => isPrefix(file.path, commonPath))) {
      break;
    }
    commonPath.pop();
  }
  return commonPath;
}

function findFolders(files) {
  if (!files || !files.length) {
    return [];
  }

  let folders = files.filter(file => file.path.length > 1).map(file => file.path[0]);
  folders = [...new Set(folders)]; // unique
  folders.sort();

  folders = folders.map(folder => {
    let filesInFolder = files
      .filter(file => file.path[0] === folder)
      .map(file => ({
        ...file,
        path: file.path.slice(1),
        parent: [...file.parent, file.path[0]],
      }));

    const children = findFolders(filesInFolder); // recursion

    return {
      is_folder: true,
      path: [folder],
      parent: files[0].parent,
      children,
      covered: children.reduce((sum, file) => sum + file.covered, 0),
      coverable: children.reduce((sum, file) => sum + file.coverable, 0),
    };
  });

  return [
    ...folders,
    ...files.filter(file => file.path.length === 1),
  ];
}

class App extends React.Component {
  constructor(...args) {
    super(...args);

    this.state = {
      current: [],
    };
  }

  componentDidMount() {
    this.updateStateFromLocation();
    window.addEventListener("hashchange", () => this.updateStateFromLocation(), false);
  }

  updateStateFromLocation() {
    if (window.location.hash.length > 1) {
      const current = window.location.hash.substr(1).split('/');
      this.setState({current});
    } else {
      this.setState({current: []});
    }
  }

  getCurrentPath() {
    let file = this.props.root;
    let path = [file];
    for (let p of this.state.current) {
      file = file.children.find(file => file.path[0] === p);
      if (!file) {
        return path;
      }
      path.push(file);
    }
    return path;
  }

  render() {
    const path = this.getCurrentPath();
    const file = path[path.length - 1];

    let w = null;
    if (file.is_folder) {
      w = e(FilesList, {
        folder: file,
        onSelectFile: this.selectFile.bind(this),
        onBack: path.length > 1 ? this.back.bind(this) : null,
      });
    } else {
      w = e(DisplayFile, {
        file,
        onBack: this.back.bind(this),
      });
    }

    return e('div', {className: 'app'}, w);
  }

  selectFile(file) {
    this.setState(({current}) => {
      return {current: [...current, file.path[0]]};
    }, () => this.updateHash());
  }

  back(file) {
    this.setState(({current}) => {
      return {current: current.slice(0, current.length - 1)};
    }, () => this.updateHash());
  }

  updateHash() {
    if (!this.state.current || !this.state.current.length) {
      window.location = '#';
    } else {
      window.location = '#' + this.state.current.join('/');
    }
  }
}

function FilesList({folder, onSelectFile, onBack}) {
  let files = folder.children;
  return e('div', {className: 'display-folder'},
    e(FileHeader, {file: folder, onBack}),
    e('table', {className: 'files-list'},
      e('thead', {className: 'files-list__head'},
        e('tr', null,
          e('th', null, "Path"),
          e('th', null, "Coverage")
        )
      ),
      e('tbody', {className: 'files-list__body'},
        files.map(file => e(File, {file, onClick: onSelectFile}))
      )
    )
  );
}

function File({file, onClick}) {
  const coverage = file.coverable ? file.covered / file.coverable * 100 : -1;

  return e('tr', {
      className: 'files-list__file'
        + (coverage >= 0 && coverage < 50 ? ' files-list__file_low': '')
        + (coverage >= 50 && coverage < 80 ? ' files-list__file_medium': '')
        + (coverage >= 80 ? ' files-list__file_high': '')
        + (file.is_folder ? ' files-list__file_folder': ''),
      onClick: () => onClick(file),
    },
    e('td', null, pathToString(file.path)),
    e('td', null,
      file.covered + ' / ' + file.coverable +
      (coverage >= 0 ? ' (' + coverage.toFixed(2) + '%)' : '')
    )
  );
}

function DisplayFile({file, onBack}) {
  return e('div', {className: 'display-file'},
    e(FileHeader, {file, onBack}),
    e(FileContent, {file})
  );
}

function FileHeader({file, onBack}) {
  return e('div', {className: 'file-header'},
    onBack ? e('a', {className: 'file-header__back', onClick: onBack}, 'Back') : null,
    e('div', {className: 'file-header__name'}, pathToString([...file.parent, ...file.path])),
    e('div', {className: 'file-header__stat'},
      'Covered: ' + file.covered + ' of ' + file.coverable +
      (file.coverable ? ' (' + (file.covered / file.coverable * 100).toFixed(2) + '%)' : '')
    )
  );
}

function FileContent({file}) {
  return e('div', {className: 'file-content'},
    file.content.split(/\r?\n/).map((line, index) => {
      const trace = file.traces.find(trace => trace.line === index + 1);
      const covered = trace && trace.stats.Line;
      const uncovered = trace && !trace.stats.Line;
      return e('pre', {
          className: 'code-line'
            + (covered ? ' code-line_covered' : '')
            + (uncovered ? ' code-line_uncovered' : ''),
          title: trace ? JSON.stringify(trace.stats, null, 2) : null,
        }, line);
    })
  );
}

(function(){
  const commonPath = findCommonPath(data.files);
  const files = data.files.map(file => ({...file, path: file.path.slice(commonPath.length), parent: commonPath}));
  const children = findFolders(files);

  const root = {
    is_folder: true,
    children,
    path: commonPath,
    parent: [],
    covered: children.reduce((sum, file) => sum + file.covered, 0),
    coverable: children.reduce((sum, file) => sum + file.coverable, 0),
  };

  ReactDOM.render(e(App, {root}), document.getElementById('root'));
}());
</script>
</body>
</html>